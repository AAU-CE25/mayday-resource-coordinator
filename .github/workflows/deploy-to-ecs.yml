name: Deploy to AWS ECS

on:
  push: 
    branches: [feature/MDAY-44-cloud-deployment]
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'ECS Cluster Name'
        required: false
        default: 'mayday-cluster'

env:
  AWS_REGION: eu-central-1
  CLUSTER_NAME: ${{ github.event.inputs.cluster_name || 'mayday-cluster' }}

jobs:
  deploy:
    name: Deploy Services to ECS
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_KAJ }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_KAJ }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set ECR Registry
        id: ecr
        run: |
          ECR_REGISTRY="${{ vars.AWS_ACCOUNT_ID_KAJ }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
      
      # ========================================
      # Get Infrastructure IDs
      # ========================================
      - name: Get VPC ID
        id: vpc
        run: |
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=${{ env.CLUSTER_NAME }}-vpc" \
            --query "Vpcs[0].VpcId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$VPC_ID" == "None" ] || [ -z "$VPC_ID" ]; then
            echo "âŒ VPC not found! Run setup-infrastructure workflow first."
            exit 1
          fi
          
          echo "vpc_id=${VPC_ID}" >> $GITHUB_OUTPUT
          echo "âœ… Found VPC: ${VPC_ID}"
      
      - name: Get Subnet IDs
        id: subnets
        run: |
          SUBNET1_ID=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${{ steps.vpc.outputs.vpc_id }}" "Name=tag:Name,Values=${{ env.CLUSTER_NAME }}-subnet-1" \
            --query "Subnets[0].SubnetId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          SUBNET2_ID=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${{ steps.vpc.outputs.vpc_id }}" "Name=tag:Name,Values=${{ env.CLUSTER_NAME }}-subnet-2" \
            --query "Subnets[0].SubnetId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "subnet1_id=${SUBNET1_ID}" >> $GITHUB_OUTPUT
          echo "subnet2_id=${SUBNET2_ID}" >> $GITHUB_OUTPUT
          echo "âœ… Found Subnets: ${SUBNET1_ID}, ${SUBNET2_ID}"
      
      - name: Get Security Group ID
        id: sg
        run: |
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=${{ steps.vpc.outputs.vpc_id }}" "Name=group-name,Values=${{ env.CLUSTER_NAME }}-sg" \
            --query "SecurityGroups[0].GroupId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "sg_id=${SG_ID}" >> $GITHUB_OUTPUT
          echo "âœ… Found Security Group: ${SG_ID}"
      
      - name: Get Target Group ARN
        id: tg
        run: |
          TG_ARN=$(aws elbv2 describe-target-groups \
            --names ${{ env.CLUSTER_NAME }}-api-tg \
            --query "TargetGroups[0].TargetGroupArn" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "tg_arn=${TG_ARN}" >> $GITHUB_OUTPUT
          echo "âœ… Found Target Group: ${TG_ARN}"
      
      - name: Get IAM Role ARN
        id: iam
        run: |
          ROLE_ARN=$(aws iam get-role \
            --role-name ${{ env.CLUSTER_NAME }}-task-execution-role \
            --query 'Role.Arn' \
            --output text)
          
          echo "role_arn=${ROLE_ARN}" >> $GITHUB_OUTPUT
          echo "âœ… Found IAM Role: ${ROLE_ARN}"
      
      - name: Get Service Discovery Namespace
        id: namespace
        run: |
          NAMESPACE_ID=$(aws servicediscovery list-namespaces \
            --query "Namespaces[?Name=='${{ env.CLUSTER_NAME }}.local'].Id | [0]" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "namespace_id=${NAMESPACE_ID}" >> $GITHUB_OUTPUT
          echo "âœ… Found Namespace: ${NAMESPACE_ID}"
      
      # ========================================
      # Task Definitions
      # ========================================
      - name: Register Database Task Definition
        run: |
          cat > /tmp/db-task-def.json << EOF
          {
            "family": "${{ env.CLUSTER_NAME }}-db",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "${{ steps.iam.outputs.role_arn }}",
            "containerDefinitions": [{
              "name": "db",
              "image": "postgres:18",
              "essential": true,
              "portMappings": [{"containerPort": 5432, "protocol": "tcp"}],
              "environment": [
                {"name": "POSTGRES_USER", "value": "postgres"},
                {"name": "POSTGRES_PASSWORD", "value": "postgres"},
                {"name": "POSTGRES_DB", "value": "mayday"},
                {"name": "PGDATA", "value": "/var/lib/postgresql/data/pgdata"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.CLUSTER_NAME }}/db",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "pg_isready -U postgres -d mayday"],
                "interval": 10, "timeout": 5, "retries": 5, "startPeriod": 30
              }
            }]
          }
          EOF
          
          aws ecs register-task-definition \
            --cli-input-json file:///tmp/db-task-def.json \
            --region ${{ env.AWS_REGION }} > /dev/null
          echo "âœ… Registered: ${{ env.CLUSTER_NAME }}-db"
      
      - name: Register API Service Task Definition
        run: |
          cat > /tmp/api-task-def.json << EOF
          {
            "family": "${{ env.CLUSTER_NAME }}-api",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "${{ steps.iam.outputs.role_arn }}",
            "containerDefinitions": [{
              "name": "api_service",
              "image": "${{ steps.ecr.outputs.registry }}/api_service:latest",
              "essential": true,
              "portMappings": [{"containerPort": 8000, "protocol": "tcp"}],
              "environment": [
                {"name": "POSTGRES_HOST", "value": "db.${{ env.CLUSTER_NAME }}.local"},
                {"name": "POSTGRES_USER", "value": "postgres"},
                {"name": "POSTGRES_PASSWORD", "value": "postgres"},
                {"name": "POSTGRES_DB", "value": "mayday"},
                {"name": "POSTGRES_PORT", "value": "5432"},
                {"name": "CORS_ALLOW_ALL", "value": "true"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.CLUSTER_NAME }}/api_service",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }]
          }
          EOF
          
          aws ecs register-task-definition \
            --cli-input-json file:///tmp/api-task-def.json \
            --region ${{ env.AWS_REGION }} > /dev/null
          echo "âœ… Registered: ${{ env.CLUSTER_NAME }}-api"
      
      - name: Register Frontend Task Definition
        run: |
          cat > /tmp/frontend-task-def.json << EOF
          {
            "family": "${{ env.CLUSTER_NAME }}-frontend",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "${{ steps.iam.outputs.role_arn }}",
            "containerDefinitions": [{
              "name": "frontend",
              "image": "${{ steps.ecr.outputs.registry }}/frontend:latest",
              "essential": true,
              "portMappings": [{"containerPort": 3000, "protocol": "tcp"}],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.CLUSTER_NAME }}/frontend",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }]
          }
          EOF
          
          aws ecs register-task-definition \
            --cli-input-json file:///tmp/frontend-task-def.json \
            --region ${{ env.AWS_REGION }} > /dev/null
          echo "âœ… Registered: ${{ env.CLUSTER_NAME }}-frontend"
      
      - name: Register SUV UI Task Definition
        run: |
          cat > /tmp/suv-ui-task-def.json << EOF
          {
            "family": "${{ env.CLUSTER_NAME }}-suv-ui",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "${{ steps.iam.outputs.role_arn }}",
            "containerDefinitions": [{
              "name": "suv_ui",
              "image": "${{ steps.ecr.outputs.registry }}/suv_ui:latest",
              "essential": true,
              "portMappings": [{"containerPort": 3030, "protocol": "tcp"}],
              "environment": [
                {"name": "PORT", "value": "3030"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.CLUSTER_NAME }}/suv_ui",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }]
          }
          EOF
          
          aws ecs register-task-definition \
            --cli-input-json file:///tmp/suv-ui-task-def.json \
            --region ${{ env.AWS_REGION }} > /dev/null
          echo "âœ… Registered: ${{ env.CLUSTER_NAME }}-suv-ui"
      
      # ========================================
      # ECS Services
      # ========================================
      - name: Deploy Database Service
        run: |
          SERVICE_NAME="${{ env.CLUSTER_NAME }}-db-service"
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} --services ${SERVICE_NAME} \
            --query "services[0].status" --output text \
            --region ${{ env.AWS_REGION }}) || true
          
          if [ "$SERVICE_STATUS" == "ACTIVE" ]; then
            aws ecs update-service --cluster ${{ env.CLUSTER_NAME }} \
              --service ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-db \
              --force-new-deployment --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸ”„ Updated: ${SERVICE_NAME}"
          else
            # Get or create service discovery
            SD_ID=$(aws servicediscovery list-services \
              --query "Services[?Name=='db'].Id" --output text \
              --region ${{ env.AWS_REGION }}) || true
            
            if [ -z "$SD_ID" ] || [ "$SD_ID" == "None" ]; then
              cat > /tmp/dns.json << EOF
          {"NamespaceId": "${{ steps.namespace.outputs.namespace_id }}", "DnsRecords": [{"Type": "A", "TTL": 60}]}
          EOF
              SD_ARN=$(aws servicediscovery create-service --name "db" \
                --namespace-id "${{ steps.namespace.outputs.namespace_id }}" \
                --dns-config file:///tmp/dns.json \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            else
              SD_ARN=$(aws servicediscovery get-service --id ${SD_ID} \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            fi
            
            aws ecs create-service --cluster ${{ env.CLUSTER_NAME }} \
              --service-name ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-db \
              --desired-count 1 --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${{ steps.subnets.outputs.subnet1_id }},${{ steps.subnets.outputs.subnet2_id }}],securityGroups=[${{ steps.sg.outputs.sg_id }}],assignPublicIp=ENABLED}" \
              --service-registries "registryArn=${SD_ARN}" \
              --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸš€ Created: ${SERVICE_NAME}"
          fi
      
      - name: Wait for Database
        run: |
          echo "â³ Waiting for database to be ready..."
          sleep 30
      
      - name: Deploy API Service
        run: |
          SERVICE_NAME="${{ env.CLUSTER_NAME }}-api-service"
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} --services ${SERVICE_NAME} \
            --query "services[0].status" --output text \
            --region ${{ env.AWS_REGION }}) || true
          
          if [ "$SERVICE_STATUS" == "ACTIVE" ]; then
            aws ecs update-service --cluster ${{ env.CLUSTER_NAME }} \
              --service ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-api \
              --force-new-deployment --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸ”„ Updated: ${SERVICE_NAME}"
          else
            SD_ID=$(aws servicediscovery list-services \
              --query "Services[?Name=='api'].Id" --output text \
              --region ${{ env.AWS_REGION }}) || true
            
            if [ -z "$SD_ID" ] || [ "$SD_ID" == "None" ]; then
              cat > /tmp/dns.json << EOF
          {"NamespaceId": "${{ steps.namespace.outputs.namespace_id }}", "DnsRecords": [{"Type": "A", "TTL": 60}]}
          EOF
              SD_ARN=$(aws servicediscovery create-service --name "api" \
                --namespace-id "${{ steps.namespace.outputs.namespace_id }}" \
                --dns-config file:///tmp/dns.json \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            else
              SD_ARN=$(aws servicediscovery get-service --id ${SD_ID} \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            fi
            
            aws ecs create-service --cluster ${{ env.CLUSTER_NAME }} \
              --service-name ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-api \
              --desired-count 1 --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${{ steps.subnets.outputs.subnet1_id }},${{ steps.subnets.outputs.subnet2_id }}],securityGroups=[${{ steps.sg.outputs.sg_id }}],assignPublicIp=ENABLED}" \
              --service-registries "registryArn=${SD_ARN}" \
              --load-balancers "targetGroupArn=${{ steps.tg.outputs.tg_arn }},containerName=api_service,containerPort=8000" \
              --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸš€ Created: ${SERVICE_NAME}"
          fi
      
      - name: Deploy Frontend Service
        run: |
          SERVICE_NAME="${{ env.CLUSTER_NAME }}-frontend-service"
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} --services ${SERVICE_NAME} \
            --query "services[0].status" --output text \
            --region ${{ env.AWS_REGION }}) || true
          
          if [ "$SERVICE_STATUS" == "ACTIVE" ]; then
            aws ecs update-service --cluster ${{ env.CLUSTER_NAME }} \
              --service ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-frontend \
              --force-new-deployment --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸ”„ Updated: ${SERVICE_NAME}"
          else
            SD_ID=$(aws servicediscovery list-services \
              --query "Services[?Name=='frontend'].Id" --output text \
              --region ${{ env.AWS_REGION }}) || true
            
            if [ -z "$SD_ID" ] || [ "$SD_ID" == "None" ]; then
              cat > /tmp/dns.json << EOF
          {"NamespaceId": "${{ steps.namespace.outputs.namespace_id }}", "DnsRecords": [{"Type": "A", "TTL": 60}]}
          EOF
              SD_ARN=$(aws servicediscovery create-service --name "frontend" \
                --namespace-id "${{ steps.namespace.outputs.namespace_id }}" \
                --dns-config file:///tmp/dns.json \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            else
              SD_ARN=$(aws servicediscovery get-service --id ${SD_ID} \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            fi
            
            aws ecs create-service --cluster ${{ env.CLUSTER_NAME }} \
              --service-name ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-frontend \
              --desired-count 1 --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${{ steps.subnets.outputs.subnet1_id }},${{ steps.subnets.outputs.subnet2_id }}],securityGroups=[${{ steps.sg.outputs.sg_id }}],assignPublicIp=ENABLED}" \
              --service-registries "registryArn=${SD_ARN}" \
              --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸš€ Created: ${SERVICE_NAME}"
          fi
      
      - name: Deploy SUV UI Service
        run: |
          SERVICE_NAME="${{ env.CLUSTER_NAME }}-suv-ui-service"
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} --services ${SERVICE_NAME} \
            --query "services[0].status" --output text \
            --region ${{ env.AWS_REGION }}) || true
          
          if [ "$SERVICE_STATUS" == "ACTIVE" ]; then
            aws ecs update-service --cluster ${{ env.CLUSTER_NAME }} \
              --service ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-suv-ui \
              --force-new-deployment --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸ”„ Updated: ${SERVICE_NAME}"
          else
            SD_ID=$(aws servicediscovery list-services \
              --query "Services[?Name=='suv-ui'].Id" --output text \
              --region ${{ env.AWS_REGION }}) || true
            
            if [ -z "$SD_ID" ] || [ "$SD_ID" == "None" ]; then
              cat > /tmp/dns.json << EOF
          {"NamespaceId": "${{ steps.namespace.outputs.namespace_id }}", "DnsRecords": [{"Type": "A", "TTL": 60}]}
          EOF
              SD_ARN=$(aws servicediscovery create-service --name "suv-ui" \
                --namespace-id "${{ steps.namespace.outputs.namespace_id }}" \
                --dns-config file:///tmp/dns.json \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            else
              SD_ARN=$(aws servicediscovery get-service --id ${SD_ID} \
                --query 'Service.Arn' --output text --region ${{ env.AWS_REGION }})
            fi
            
            aws ecs create-service --cluster ${{ env.CLUSTER_NAME }} \
              --service-name ${SERVICE_NAME} --task-definition ${{ env.CLUSTER_NAME }}-suv-ui \
              --desired-count 1 --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${{ steps.subnets.outputs.subnet1_id }},${{ steps.subnets.outputs.subnet2_id }}],securityGroups=[${{ steps.sg.outputs.sg_id }}],assignPublicIp=ENABLED}" \
              --service-registries "registryArn=${SD_ARN}" \
              --region ${{ env.AWS_REGION }} > /dev/null
            echo "ðŸš€ Created: ${SERVICE_NAME}"
          fi
      
      # ========================================
      # Wait and Summary
      # ========================================
      - name: Wait for services to stabilize
        run: |
          echo "â³ Waiting for services to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.CLUSTER_NAME }} \
            --services ${{ env.CLUSTER_NAME }}-api-service ${{ env.CLUSTER_NAME }}-frontend-service ${{ env.CLUSTER_NAME }}-suv-ui-service \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ Services timeout - may still be deploying"
      
      - name: Get Service Public IPs
        id: ips
        run: |
          echo "ðŸ“¡ Getting Service Public IPs..."
          TASKS=$(aws ecs list-tasks --cluster ${{ env.CLUSTER_NAME }} \
            --query "taskArns" --output text --region ${{ env.AWS_REGION }})
          
          FRONTEND_IP=""
          SUV_UI_IP=""
          
          for task in $TASKS; do
            INFO=$(aws ecs describe-tasks --cluster ${{ env.CLUSTER_NAME }} --tasks $task \
              --query "tasks[0].{name:containers[0].name,eni:attachments[0].details[?name=='networkInterfaceId'].value|[0]}" \
              --output json --region ${{ env.AWS_REGION }})
            
            NAME=$(echo $INFO | jq -r '.name')
            ENI=$(echo $INFO | jq -r '.eni')
            
            if [ "$ENI" != "null" ]; then
              IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI \
                --query "NetworkInterfaces[0].Association.PublicIp" \
                --output text --region ${{ env.AWS_REGION }})
              echo "${NAME}: ${IP}"
              
              if [ "$NAME" == "frontend" ]; then
                FRONTEND_IP="${IP}"
              elif [ "$NAME" == "suv_ui" ]; then
                SUV_UI_IP="${IP}"
              fi
            fi
          done
          
          echo "frontend_ip=${FRONTEND_IP}" >> $GITHUB_OUTPUT
          echo "suv_ui_ip=${SUV_UI_IP}" >> $GITHUB_OUTPUT
      
      - name: Get ALB DNS
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names ${{ env.CLUSTER_NAME }}-api-alb \
            --query "LoadBalancers[0].DNSName" \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "alb_dns=${ALB_DNS}" >> $GITHUB_OUTPUT
      
      - name: Print Deployment Summary
        run: |
          echo "## ðŸš€ ECS Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Public Access Points" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| **API** | http://${{ steps.alb.outputs.alb_dns }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Frontend** | http://${{ steps.ips.outputs.frontend_ip }}:3000 |" >> $GITHUB_STEP_SUMMARY
          echo "| **SUV UI** | http://${{ steps.ips.outputs.suv_ui_ip }}:3030 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Services Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- db-service" >> $GITHUB_STEP_SUMMARY
          echo "- api-service (behind ALB)" >> $GITHUB_STEP_SUMMARY
          echo "- frontend-service" >> $GITHUB_STEP_SUMMARY
          echo "- suv-ui-service" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Internal Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Endpoint |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| Database | db.${{ env.CLUSTER_NAME }}.local:5432 |" >> $GITHUB_STEP_SUMMARY
          echo "| API | api.${{ env.CLUSTER_NAME }}.local:8000 |" >> $GITHUB_STEP_SUMMARY

  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    steps:
      - name: Print failure summary
        run: |
          echo "## âŒ ECS Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tip:** Make sure you've run the \`setup-infrastructure\` workflow first!" >> $GITHUB_STEP_SUMMARY
